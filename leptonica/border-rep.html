


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Border Representations of Connected Components &mdash; Leptonica Documentation v1.68 documentation</title>
    <link rel="stylesheet" href="../_static/leptonica.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.68',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="top" title="Leptonica Documentation v1.68 documentation" href="../index.html" />
    <link rel="up" title="Image Processing Applications" href="applications.html" />
    <link rel="next" title="Document Image Analysis" href="document-image-analysis.html" />
    <link rel="prev" title="Color Segmentation" href="color-segmentation.html" />
 
    <link href='http://fonts.googleapis.com/css?family=Droid+Serif:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Droid+Sans:regular,bold' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
    <script type="text/javascript" src="http://www.google-analytics.com/urchin.js"></script>
    <script type="text/javascript" src="../_static/sort-filter-table-compact.js"></script>
   


  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="document-image-analysis.html" title="Document Image Analysis"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="color-segmentation.html" title="Color Segmentation"
             accesskey="P">previous</a> |</li>
  <li><a href="http://www.leptonica.com">Leptonica Home</a> &raquo;</li>
  
        <li><a href="../index.html">Unofficial v1.68 Documentation</a> &raquo;</li>

          <li><a href="index.html" >The Leptonica Image Processing Library</a> &raquo;</li>
          <li><a href="applications.html" accesskey="U">Image Processing Applications</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="border-representations-of-connected-components">
<h1>Border Representations of Connected Components<a class="headerlink" href="#border-representations-of-connected-components" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">date:</th><td class="field-body">Aug 31, 2006</td>
</tr>
</tbody>
</table>
<div class="section" id="overview-of-connected-component-borders">
<h2>Overview of connected component borders<a class="headerlink" href="#overview-of-connected-component-borders" title="Permalink to this headline">¶</a></h2>
<p>The generation of connected component (c.c.) borders is a relatively
simple application in <strong>Leptonica</strong>. There are many rendering machines
that can convert outlines to binary images. PostScript and other page
description languages use outline fonts for scalable rendering, to get
smooth pixellated curves at any output device resolution. There are
several different font formats in use, such as the original PostScript
outline fonts, Microsoft&#8217;s TrueType fonts, and the open source FreeType
fonts.</p>
<p>Borders of connected components can be generated by following either
the border pixels or the &#8220;cracks&#8221; between border pixels of different
colors. The first type are called <em>chain codes</em>; the second are <em>crack
codes</em>. It is relatively simple to convert crack codes to chain codes,
but we will use chain codes throughout. Borders must be followed
consistently so that the <em>inside</em> of the c.c. is on either the left or
right. We choose having the inside on the right side, so that outer
borders are traversed cw and inner (hole) borders are traversed ccw.</p>
<p>After the chain code for the border(s) of a c.c. are determined, the
following constructions are of interest:</p>
<ul>
<li><p class="first">Finding a compressed, serialized format for writing to a file.</p>
</li>
<li><p class="first">Linking the outer border with all inner borders to form a single,
connected chain for each c.c.</p>
</li>
<li><p class="first">Rendering the outline as the original raster.</p>
</li>
</ul>
<p>Let&#8217;s look at each of the operations in some detail. The source is in
<span class="filesystem">ccbord.c</span> and <span class="filesystem">ccbord.h</span>, which should be consulted for further
details.</p>
</div>
<div class="section" id="generating-chain-codes-for-connected-components">
<h2>Generating chain codes for connected components<a class="headerlink" href="#generating-chain-codes-for-connected-components" title="Permalink to this headline">¶</a></h2>
<p>We first find the bitmaps and bounding boxes for each 8-connected
component. The border of an 8-connected component is represented by an
8-connected chain of pixels. Then for each c.c., the outer border is
found by first adding a one-pixel border of OFF pixels to the <tt class="docutils literal"><span class="pre">PIX</span></tt>
for the c.c., finding a first border pixel in the fg (i.e., an ON pixel
next to an OFF pixel), and sequentially finding the next pixel on the
border. We use a method described by Rosenfeld and Kak in
<cite>Digital Picture Processing</cite>, <cite class="jvolume">Vol 2</cite>, pp. 219ff,
<cite class="publisher">Academic Press</cite>, 1982.  The next pixel in an 8-connected
border is found by looking in the 8 directions from the current pixel,
starting with the pixel next in cw rotation from the previous border
pixel. The search sweeps around until an ON pixel is found. The chain is
terminated after the first pixel is reached again AND the next pixel
would be the second pixel in the chain. This is necessary because pixels
can be traversed on the chain multiple times (up to 4 times; consider a
3x3 plus sign).</p>
<p>Remember, the background to 8-connected foreground is 4-connected. The
holes are found as follows. We take each minimum-sized image of an 8
c.c., and use 4-filling from the border. This fill stops when you hit
the outside of the c.c. Then inverting the result, you get an image of
the holes (if any) as 4-connected fg objects. Run the c.c. finder
looking for these 4-connected objects. Then for each hole, the hole
border in the fg of the original c.c. is found by first finding a
pixel within the hole, then searching in the original c.c. for a
border pixel, and then following the border to generate the chain
code. Doing it this way, we are guaranteed to find all holes within
components, and not to run into trouble in very complicated situations
where there can be components within holes within components, etc,
nested to any arbitrary depth.</p>
</div>
<div class="section" id="serializing-the-data-for-a-compressed-file-format">
<h2>Serializing the data for a compressed file format<a class="headerlink" href="#serializing-the-data-for-a-compressed-file-format" title="Permalink to this headline">¶</a></h2>
<p>We show a simple way to do this, that gives a typical compression on
text images that is about 25% better on borders of connected
components than using png on the original image. If there are
halftones, you can expect worse compression than png. These outline
representations should generally not be used on halftones, but they
work well with text and unstippled line art.</p>
<p>The chain code can be represented as a sequence of directions for each
step. There are 8 directions, so this requires 3 bits of information.
Pack 2 steps into each byte. You can do better, putting 8 steps into 3
bytes, but gzip, which works on bytes, will be less successful at
compressing such data, and we use gzip on the sequential step data.
For each c.c. you also need to store the UL corner coordinates, and
for each border (both outer and hole) you need to store the
coordinates of the starting pixel. We also store the width and height
of each c.c., but this is not necessary because it can be determined
from the outer border. This data is collected in memory, using the
byte buffer utility in <span class="filesystem">bbuffer.c</span>. It is then compressed in memory
with gzip and written out to file. It can be read back, gunzip&#8217;d in
memory, and parsed, with the construction of the <tt class="docutils literal"><span class="pre">CCBORDA</span></tt> data
structure.</p>
<p>There are other ways to do this. For example, we can store run-lengths
at each direction rather than single steps. We can compress using a
Huffman code on run-lengths, rather than a universal code on bytes
composed of 2-step direction codes. I adopted the approach here
because it&#8217;s easy to implement using the byte buffer utility and the
in-memory gzip functions.</p>
</div>
<div class="section" id="forming-a-single-border-for-each-connected-component">
<h2>Forming a single border for each connected component<a class="headerlink" href="#forming-a-single-border-for-each-connected-component" title="Permalink to this headline">¶</a></h2>
<p>Kris Popat suggested that it is useful to connect the hole borders
with the outer border, so that there is a single border for each c.c.
(In fact, this whole chain code representation is Kris&#8217;s suggestion.)
To avoid having artifacts generated by the rendering machine, each
<em>cut path</em> between inner and outer borders is traversed twice, in
opposite directions, along exactly the same pixel path. The renderers
are usually smart enough to figure out what is inside and what is
outside.</p>
<p>The implementation is most simple if we find a path from each hole
border to the outer border, making sure that it is fully contained
within the fg of the c.c. We use again a bitmap of the c.c. under
study. For each hole, we start at the center of the hole, making sure it
is an OFF pixel, and march in one of 4 directions until we find an ON
pixel, which must be on the hole border. We then continue in the same
direction until we hit either an OFF pixel or an ON pixel at the edge of
the bitmap. Check if the last ON pixel is on the outer border of the
c.c. If it is, we have our cut path; if not, choose another of the four
directions and repeat. This way we have four chances. Because the
application is for text, where the most likely joining of characters is
horizontal, we pick the first two directions vertically and the last two
horizontally. If we fail in all four directions, we just lose a hole.</p>
<p>Then, once a cut path is located for each hole, we start on the outer
border. When we come to a cut path, we take it, go around the hole,
come back on the cut path to the outer border, and continue there.
After the outer border has been completely traversed, we are finished.</p>
<p>For completeness, I note that we offer the following representations
of the chain code in the <tt class="docutils literal"><span class="pre">CCBORDA</span></tt> data structure:</p>
<ul>
<li><p class="first">Separate outer and hole borders, in local coords in the c.c.</p>
</li>
<li><p class="first">Separate outer and hole borders, in global coords</p>
</li>
<li><p class="first">Separate outer and hole borders, in step (direction) codes</p>
</li>
<li><p class="first">Single border with cut paths, in local coords in the c.c.</p>
</li>
<li><p class="first">Single border with cut paths, in global coords. For this, you can
have either all the points on the border, or just the turning points,
so that a straight line between turning points intersects all the
actual border pixels. For a typical image, using turning points
reduces the number of stored points by a factor of about 2.</p>
</li>
</ul>
</div>
<div class="section" id="rendering-the-outline-as-a-filled-raster">
<h2>Rendering the outline as a filled raster<a class="headerlink" href="#rendering-the-outline-as-a-filled-raster" title="Permalink to this headline">¶</a></h2>
<p>The standard method for filling outlines is <em>scan line conversion</em>.
This sweeps a line across the image, noting when it goes through end
points of oriented line segments, and keeping track of how many lines
(and, optionally, their orientations) that it cuts. You can understand
how this works intuitively by tracking across just one raster line,
starting at the left edge. Suppose you start in bg. The first line you
cross will be oriented up, and after crossing it you will be in fg.
(This follows our convention that <em>inside</em> is on the right as you
traverse the path.) For simple shapes, each line you cross will be
oriented oppositely to the preceeding line, and you will toggle from fg
&lt;&#8211;&gt; bg. In the general case there can be any number of lines oriented
up or down, and a rule is needed to determine what to do when
crossing. There are two common rules:</p>
<ol class="arabic">
<li><p class="first"><em>Nonzero winding number rule.</em> Sum the crossings, using +1 if the
path crosses oriented up and -1 if it is going down. If the sum is 0,
you are in bg; otherwise, you are in fg.</p>
</li>
<li><p class="first"><em>Even-odd rule.</em> Sum the crossings, independent of path
orientation. If the sum is even, you are in bg; otherwise, you are in
fg.</p>
</li>
</ol>
<p>For simple shapes, these two rules give the same result, but for complex
paths they will differ. Using the nonzero winding number rule, if you
pass 2 lines both oriented up, the winding number is 2; you are still in
fg and will remain there until the winding number has gone back
to 0. Scan line conversion has not yet been implemented in <strong>Leptonica</strong>.</p>
<p>We provide instead two topological algorithms for filling the
outlines, which are represented as separate outer and hole borders for
each c.c. These are the functions <tt class="docutils literal"><span class="pre">ccbaDisplayImage1()</span></tt> and
<tt class="docutils literal"><span class="pre">ccbaDisplayImage2()</span></tt>. Both algorithms are described in some detail
at the top of <span class="filesystem">ccbord.c</span>. The algorithms are very similar, but
Method 2 is a little simpler, so I describe it here.</p>
<p>Each 8-connected component is filled separately, and then rasterop&#8217;d
into the destination image. For each c.c.,</p>
<ol class="arabic">
<li><p class="first">Make a <tt class="docutils literal"><span class="pre">PIX</span></tt> with the border pixels in the c.c. in the fg, and
with an added 1 pixel border of bg pixels. If w and h are the width
and height of the c.c., the <tt class="docutils literal"><span class="pre">PIX</span></tt> has width w+2 and height h+2. This
is the clipping mask.</p>
</li>
<li><p class="first">Make a seed image of the same size, and for each border (both outer
and holes) put one seed pixel <em>outside</em> the border. &#8220;Outside&#8221; is
determined by our right-hand convention for borders. The 1 pixel
border was added to each image to simplify the procedure for finding a
seed outside the outer border of the c.c.; namely, by guaranteeing
that those pixels are accessible as seeds.</p>
</li>
<li><p class="first">Fill the seed image, using the border pixels as a clipping mask to
stop each fill at the borders. This is done with
<tt class="docutils literal"><span class="pre">pixSeedfillBinary()</span></tt>, inverting the clipping mask to make it a
filling mask, and using 4-connected filling for the bg. We have now
filled both the holes and the region outside the outer border of the
c.c.</p>
</li>
<li><p class="first">Invert the seed image, to get the properly filled c.c, still
centered in the oversize (by 2 pixels) <tt class="docutils literal"><span class="pre">PIX</span></tt>.</p>
</li>
<li><p class="first">Rasterop using XOR the filled c.c. (but not including the outer 1
pixel boundary) into the full dest image.</p>
</li>
</ol>
<p>This is relatively fast, requiring only seedfill and rasterop as the
basic bit-parallel functions.</p>
</div>
<div class="section" id="putting-it-together">
<h2>Putting it together<a class="headerlink" href="#putting-it-together" title="Permalink to this headline">¶</a></h2>
<p>You can run all these operations with <span class="filesystem">prog/ccbordtest.c</span>. Let R be
the ratio of 8-c.c. to 4-c.c. For typical text, R is very close to 1.
However, if halftones are present, R can be much smaller than 1. The
following three page images were used to test different aspects of the
border finding and rendering routines:</p>
<ul>
<li><p class="first"><span class="filesystem">feyn.png</span>. This is a typical scan of a text page, with R =
4305/4452. Many of the c.c. are multiple characters within a word that
have been joined.</p>
</li>
<li><p class="first"><span class="filesystem">witten.png</span>. This is a high quality scanned page, with R =
4972/5208. It has very few touching characters. However, it has a
large stippled &#8220;O&#8221; that has many small holes, and our algorithm for
joining interior hole borders with the outer border misses three of
them.</p>
</li>
</ul>
<div align="center" class="align-center"><img alt="Stippled letter &quot;O&quot;" class="border align-center" src="../_images/stippled.png" /></div>
<ul>
<li><p class="first"><span class="filesystem">rabi.png</span>. This has a large, topologically complicated halftone
pattern on the page. One of the c.c. in the halftone contains 351
holes! Most of the c.c. in the page are in the halftone: the ratio R =
21748/98981 is much less than 1. To reduce output when the outer and
hole borders are joined into a single path, we set a maximum number of
holes for any c.c, and if this number is exceeded, we assume the
component is not text and no hole borders are connected. It will
consequently be rasterized (filled) without holes. (By contrast, the
topological renderer, which uses separate hole and outer borders,
rasterizes the image correctly, regardless of the number of holes.)</p>
</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div style="text-align: center; padding-right: 5px;">
 <a href="http://www.leptonica.com" >
  <img src="../_static/moller52-smaller.jpg" border="0" alt="Leptonica Home"/>
 </a>
</div>



<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Leptonica Image Processing Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="README.html">README</a></li>
<li class="toctree-l2"><a class="reference internal" href="local-sources.html">Source Code and Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="source-downloads.html">Source Downloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="library-overview.html">Overview of the Leptonica Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="library-notes.html">Supplemental Notes on Using the Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="functions.html"><strong>Leptonica</strong> API</a></li>
<li class="toctree-l2"><a class="reference internal" href="src-dir.html"><span class="filesystem">/src</span> Directory Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="prog-dir.html"><span class="filesystem">/prog</span> Directory Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="operations.html">Image Processing Operations</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="applications.html">Image Processing Applications</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="line-removal.html">Removing dark lines from a light pencil drawing</a></li>
<li class="toctree-l3"><a class="reference internal" href="dewarping.html">Dewarping Text Pages</a></li>
<li class="toctree-l3"><a class="reference internal" href="skew-measurement.html">Measuring the Skew of Document Images</a></li>
<li class="toctree-l3"><a class="reference internal" href="color-quantization.html">Color Quantization</a></li>
<li class="toctree-l3"><a class="reference internal" href="color-segmentation.html">Color Segmentation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Border Representations of Connected Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview-of-connected-component-borders">Overview of connected component borders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-chain-codes-for-connected-components">Generating chain codes for connected components</a></li>
<li class="toctree-l4"><a class="reference internal" href="#serializing-the-data-for-a-compressed-file-format">Serializing the data for a compressed file format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#forming-a-single-border-for-each-connected-component">Forming a single border for each connected component</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rendering-the-outline-as-a-filled-raster">Rendering the outline as a filled raster</a></li>
<li class="toctree-l4"><a class="reference internal" href="#putting-it-together">Putting it together</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="document-image-analysis.html">Document Image Analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="jbig2.html">Jbig2 Classifier</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="byte-addressing.html">Byte Addressing for Efficiency and Portability</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing-methods.html">What is &#8220;Well-Tested&#8221; C Code?</a></li>
<li class="toctree-l2"><a class="reference internal" href="design-principles.html">Some Issues in Software Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="recent-pubs.html">Selected Papers on Image Processing and Image Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="about-the-license.html">About the Copyright License</a></li>
<li class="toctree-l2"><a class="reference internal" href="about-the-name.html">What is the Significance of the Name &#8220;leptonica&#8221;?</a></li>
<li class="toctree-l2"><a class="reference internal" href="version-notes.html">Version Notes for Leptonica</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vs2008/index.html">Leptonica &amp; Visual Studio 2008</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other/index.html">Other Topics</a></li>
</ul>


  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/leptonica/border-rep.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="document-image-analysis.html" title="Document Image Analysis"
             >next</a></li>
        <li class="right" >
          <a href="color-segmentation.html" title="Color Segmentation"
             >previous</a> |</li>
  <li><a href="http://www.leptonica.com">Leptonica Home</a> &raquo;</li>
  
        <li><a href="../index.html">Unofficial v1.68 Documentation</a> &raquo;</li>

          <li><a href="index.html" >The Leptonica Image Processing Library</a> &raquo;</li>
          <li><a href="applications.html" >Image Processing Applications</a> &raquo;</li> 
      </ul>
    </div>
  <div class="footer">

   <span class="creativecommons">
    <a href="http://creativecommons.org/licenses/by/3.0/us/" >
      <img src="../_static/creativecommons-88x31.png"
	   border="0" alt="Creative Commons License"/>
     </a>
    Leptonica by 
    <a href="http://leptonica.com/www.leptonica.org">
    Dan Bloomberg
    </a>
    is licensed under a
    <a href="http://creativecommons.org/licenses/by/3.0/us/">
     Creative Commons Attribution 3.0 United States License.
    </a>
   </span>

   
   <span class="sphinxcreditr">
   Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
   </span>
   

    <script type="text/javascript">
      _uacct = "UA-144810-1";
      urchinTracker();
    </script>
  </div>
  </body>
</html>