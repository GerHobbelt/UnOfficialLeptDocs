


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta content="IE=EmulateIE7" http-equiv="X-UA-Compatible" />

    <title>Affine Transformations (and cousins) &mdash; Leptonica Documentation v1.67 documentation</title>
    <link rel="stylesheet" href="../_static/leptonica.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.67',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="top" title="Leptonica Documentation v1.67 documentation" href="../index.html" />
    <link rel="up" title="Image Processing Operations" href="operations.html" />
    <link rel="next" title="Seed Filling and Connected Components" href="filling.html" />
    <link rel="prev" title="Image Rotation" href="rotation.html" />
 
    <script type="text/javascript" src="http://www.google-analytics.com/urchin.js"></script>
    <script type="text/javascript" src="../_static/sort-filter-table-compact.js"></script>
  <script src="/javascripts/other/MathJax/MathJax.js" type="text/javascript">
    if (window.location.protocol == "https:") {
      MathJax.OutputJax.fontDir = "https://" + document.location.host + "/assets/MathJax/fonts"
    } else {
      MathJax.OutputJax.fontDir = "http://" + document.location.host + "/assets/MathJax/fonts"
    }
    MathJax.Hub.Config({
      extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
      jax: ["input/TeX", "output/HTML-CSS"]
    })
  </script>


  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="filling.html" title="Seed Filling and Connected Components"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="rotation.html" title="Image Rotation"
             accesskey="P">previous</a> |</li>
  <li><a href="http://www.leptonica.com">Leptonica Home</a> &raquo;</li>
  
        <li><a href="../index.html">Unofficial v1.67 Documentation</a> &raquo;</li>

          <li><a href="index.html" >The Leptonica Image Processing Library</a> &raquo;</li>
          <li><a href="operations.html" accesskey="U">Image Processing Operations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="affine-transformations-and-cousins">
<span id="affine-transformations"></span><h1>Affine Transformations (and cousins)<a class="headerlink" href="#affine-transformations-and-cousins" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">date:</th><td class="field-body">Aug 10, 2006</td>
</tr>
</tbody>
</table>
<div class="contents local topic" id="contents">
<ul>
<li><p class="first"><a class="reference internal" href="#what-is-an-affine-transformation" id="id1">What is an affine transformation?</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#how-are-affine-transformations-implemented" id="id2">How are affine transformations implemented?</a></p>
<ul>
<li><p class="first"><a class="reference internal" href="#sequential-affine-transform" id="id3">Sequential affine transform</a></p>
</li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="#some-related-transforms" id="id4">Some related transforms</a></p>
<ul>
<li><p class="first"><a class="reference internal" href="#conformal-affine-transform" id="id5">Conformal affine transform</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#projective-transform" id="id6">Projective transform</a></p>
</li>
<li><p class="first"><a class="reference internal" href="#bilinear-transform" id="id7">Bilinear transform</a></p>
</li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="#shearing-an-image" id="id8">Shearing an image</a></p>
</li>
</ul>
</div>
<div class="section" id="what-is-an-affine-transformation">
<h2><a class="toc-backref" href="#id1">What is an affine transformation?</a><a class="headerlink" href="#what-is-an-affine-transformation" title="Permalink to this headline">¶</a></h2>
<p>An <em>affine transformation</em> is the most general linear transformation
on an image:</p>
<div class="math" id="equation-general-linear-transformation">
<span class="eqno">(1)</span>\[\begin{split}\begin{align}
x' &amp;= ax + by + c\\
y' &amp;= dx + ey + f\\
\end{align}\end{split}\]</div>
<p>or in (transposed) matrix notation:</p>
<div class="math" id="equation-matrix-form">
<span class="eqno">(2)</span>\[\begin{split}\begin{bmatrix}
  x'&amp; y'
\end{bmatrix}
=
\begin{bmatrix}
  x &amp; y &amp; 1
\end{bmatrix} \, T\end{split}\]</div>
<p>where T is a 3x2 matrix of coefficients:</p>
<div class="math" id="equation-T">
<span class="eqno">(3)</span>\[\begin{split}T = \begin{bmatrix}
      a &amp; d \\
      b &amp; e \\
      c &amp; f
    \end{bmatrix}\end{split}\]</div>
<p>There are a couple of ways this can be visualized geometrically. If
you look at a two-dimensional surface (coordinate system) from a great
distance with arbitrary orientation in the third dimension, you will
see that any object in the two-dimensional surface appears to be
distorted by a combination, in general, of translation, shear and
scaling. So an affine transformation takes any coordinate system in a
plane into another coordinate system that can be found from such a
projection. Under affine transformation, parallel lines remain
parallel and straight lines remain straight.</p>
<p>Consider this transformation of coordinates. A coordinate system (or
<em>coordinate space</em>) in two-dimensions is defined by an origin, two
non-parallel axes (they need not be perpendicular), and two scale
factors, one for each axis. This can be described by 3 points, one for
the origin and one for the unit distance along each of the two axes.  It
takes six numbers to specify three points. Suppose we have these three
points: <span class="math">\((x_1, y_1)\)</span>, <span class="math">\((x_2, y_2)\)</span> and <span class="math">\((x_3, y_3)\)</span>. Then given an
affine transformation as above, we can find the corresponding three
transformed points from:</p>
<div class="math" id="equation-3pt-transformation">
<span class="eqno">(4)</span>\[\begin{split}\begin{align}
x'_1 &amp;= ax_1 + by_1 + c \\
y'_1 &amp;= dx_1 + ey_1 + f \\
x'_2 &amp;= ax_2 + by_2 + c \\
y'_2 &amp;= dx_2 + ey_2 + f \\
x'_3 &amp;= ax_3 + by_3 + c \\
y'_3 &amp;= dx_3 + ey_3 + f
\end{align}\end{split}\]</div>
<p>Conversely, if we are given the three points in the transformed (primed)
coordinate space that correspond to the three unprimed points, we could
solve the set of 6 equations in <a href="#equation-3pt-transformation">(4)</a> for the six
coefficients. These coefficents could then be used in
<a href="#equation-general-linear-transformation">(1)</a> to transform any point in the
original coordinate space to its location in the primed coordinate
space.</p>
</div>
<div class="section" id="how-are-affine-transformations-implemented">
<h2><a class="toc-backref" href="#id2">How are affine transformations implemented?</a><a class="headerlink" href="#how-are-affine-transformations-implemented" title="Permalink to this headline">¶</a></h2>
<p>There are two very different approaches to implement an affine
transformation on an image:</p>
<ol class="arabic">
<li><p class="first"><strong>Pointwise.</strong> Each point in the dest is determined from the
corresponding point in the src. We start with 3 points specifying the
initial coordinate space and the 3 corresponding points that specify
the transformed coordinate space, and transform an entire image
pointwise by the transformation <a href="#equation-general-linear-transformation">(1)</a>.</p>
</li>
<li><p class="first"><strong>Sequential.</strong> The entire image is successively transformed by a
sequence of shear, scale and translation operations.</p>
</li>
</ol>
<p>In practice, the pointwise approach is the most useful. For each dest
pixel, the corresponding src pixel (or pixels) are located, and the
dest pixel value is computed.</p>
<p>For binary images, the <em>pointwise</em> transform is about 3 times slower
than the <em>sequential</em> transform, whereas for grayscale images the
pointwise transform is an order of magnitude faster! However, of more
importance, the results, particularly on text, are far better with the
pointwise transform. The sequential transform involves a number of
shears, which cause visible dislocation lines through characters.
After such a set of sequential transforms, the edges, that were
initially smooth, become irregular, significantly degrading the visual
quality of the text. The pointwise transform has a minimal number of
such artifacts, and any shear lines that are developed tend to have
shorter spatial correlation. It is thus strongly urged that <em>in any
situation where the quality of the resulting text image is important,
the pointwise transformation should be used.</em></p>
<p>The following image fragments show the image quality resulting from
the same affine transformation. The first fragment has been done
pointwise, whereas the second one was done sequentially.</p>
<div class="figure align-center">
<img alt="Pointwise affine transformation" class="border" src="../_images/pointwise-affine.png" />
<p class="caption">Figure 1 &#8211; Pointwise Affine Transformation</p>
</div>
<div class="figure align-center">
<img alt="Sequential affine transformation" class="border" src="../_images/sequential-affine.png" />
<p class="caption">Figure 2 &#8211; Sequential Affine Transformation</p>
</div>
<p>See the documentation in <span class="filesystem">affine.c</span>, where it is shown that the
pointwise transformation should be performed <em>backwards</em>, so that for
every point in the (primed) dest, you find the corresponding point in
the (unprimed) src. For binary images, the implementation is slower in
the backwards direction, because you have to find the corresponding
point in the src for <em>every</em> point in the dest, whereas going in the
forward direction, you only write to the dest when the src pixel is
ON. However, the forward direction implementation can miss some pixels
entirely in the dest. When a solid black region is transformed, this
will in general result in a regular pattern of white pixels within it,
even when no overall scaling is done.</p>
<p>With the affine transform, as with the <a class="reference internal" href="#affine-projective-transform"><em>projective</em></a> and <a class="reference internal" href="#affine-bilinear-transform"><em>bilinear transforms</em></a>, the pointwise transform can be done for
all pixel depths by <em>sampling</em>. For 8 bpp and RGB images, better results
are obtained, particularly on document images that have sharp edges,
using <em>interpolation</em>. Interpolation involves subdividing the src pixels
into subpixels (we divide each into 16 x 16 subpixels), and using the
subpixel location to generate weighting factors for the four neighboring
src pixels. Interpolation is about 5x slower than sampling the nearest
src pixel. When there is relatively little scale change, interpolation
is nearly equivalent to area mapping, as we have shown with
<a class="reference internal" href="rotation.html#rotation-by-area-mapping"><em>rotation</em></a>.</p>
<div class="section" id="sequential-affine-transform">
<h3><a class="toc-backref" href="#id3">Sequential affine transform</a><a class="headerlink" href="#sequential-affine-transform" title="Permalink to this headline">¶</a></h3>
<p>We now describe the situation where the affine transform is performed as
a sequence of translations, scalings, shears and, optionally,
rotations. Because a rotation is equivalent to <a class="reference internal" href="rotation.html#rotation-by-shear"><em>three shears</em></a>), we need in principle only translations, scaling
and shear. We have already demonstrated that there are 6 independent
parameters in the affine transformation. This can also be seen from the
transformation from one coordinate space to another. There are 2
parameters to align the origins, 2 parameters for the scaling of the two
axes, and 2 parameters describing the <em>change</em> in angle of each
axis. Now, suppose you are given the two coordinate spaces, and want to
transform from one to the other. How do we do this with the image
operations in <strong>Leptonica</strong>?</p>
<p>These operations are as follows:</p>
<ul>
<li><p class="first">Arbitrary translation, implemented by <tt class="docutils literal"><span class="pre">pixRasterop()</span></tt>. We also have
an in-place version <tt class="docutils literal"><span class="pre">pixRasteropIP()</span></tt>.</p>
</li>
<li><p class="first">Anisotropic scaling in x and y, implemented by <tt class="docutils literal"><span class="pre">pixScale()</span></tt>.</p>
</li>
<li><p class="first">Horizontal shear about an arbitrary horizontal line <tt class="docutils literal"><span class="pre">pixHShear()</span></tt>,
with an in-place version <tt class="docutils literal"><span class="pre">pixHShearIP()</span></tt>.</p>
</li>
<li><p class="first">Vertical shear about an arbitrary vertical line <tt class="docutils literal"><span class="pre">pixVShear()</span></tt>, with
an in-place version <tt class="docutils literal"><span class="pre">pixVShearIP()</span></tt>.</p>
</li>
<li><p class="first">Rotation about an arbitrary point, implemented by
<tt class="docutils literal"><span class="pre">pixRotateShear()</span></tt>, with an in-place version <tt class="docutils literal"><span class="pre">pixRotateShearIP()</span></tt>.</p>
</li>
</ul>
<p>To make use of these transforms to align our two coordinate spaces, we
use the following construction, described also in <span class="filesystem">affine.c</span>. The
problem to be solved is to take an image with one coordinate space
(unprimed) and transform it by an affine transformation to coincide
with another coordinate space (primed). We use only shears parallel to
the x and y axes, orthogonal scaling with scaling factors in x and y,
and translation.</p>
<p>A typical application is to align the image with a second image in
another coordinate space, related by the affine transformation. This
invites the following model for making the affine transform. Imagine
that the unprimed coordinate space is in our original image (image 1)
and the corresponding primed coordinate space is in a second image
(image 2). We can transform <em>both</em> images so that the coordinate spaces
coincide and are aligned with the x and y axes. After both the unprimed
and primed coordinate spaces are coincident, we finally shear the
unprimed coordinate space to coincide with the original primed
space. Thus, all operations really happen on a single image.
Specifically, we do the following:</p>
<ol class="arabic">
<li><p class="first"><em>Horizontal shear transform</em> about point 1 to align point 3 with
the y axis.</p>
</li>
<li><p class="first"><em>Vertical shear transform</em> about point 1 to align point 2 with the x
axis.</p>
</li>
<li><p class="first"><em>Compute the horizontal shear angle and the final location of point</em>
<span class="math">\(3'\)</span> required to put point <span class="math">\(3'\)</span> on the y axis.</p>
</li>
<li><p class="first"><em>Compute the vertical shear angle and the final location of point</em>
<span class="math">\(2'\)</span> required to put point <span class="math">\(2'\)</span> on the x axis.</p>
</li>
<li><p class="first"><em>Scale</em> x and y axes anisotropically so that points 2 and 3, which
are on the x and y axes, move out to a distance equal to the distance
of the newly sheared points <span class="math">\(2'\)</span> and <span class="math">\(3'\)</span> from their origin
<span class="math">\(1'\)</span>. This scaling operation will translate the origin (point 1).</p>
</li>
<li><p class="first"><em>Translate</em> the origin 1, after it has been moved by scaling, to
coincide with the origin <span class="math">\(1'\)</span>.</p>
</li>
<li><p class="first"><em>Vertical shear transform</em> about the new origin (point 1, which is
now aligned with <span class="math">\(1'\)</span>), using the negative of the angle computed in
step 3 above.</p>
</li>
<li><p class="first"><em>Horizontal shear transform</em> about the new origin (point 1), using
the negative of the angle computed in step 4 above.</p>
</li>
</ol>
<p>In all this, it is only necessary to keep track of the shear angles and
translations of points during the shears. What has been accomplished is
a general affine transformation on the image. See <span class="filesystem">affine.c</span> for the
specifics of the implementation.</p>
<p>Use these links for more detail on <a class="reference internal" href="rotation.html"><em>rotation</em></a>,
<a class="reference internal" href="rasterops.html#what-else-rasterops"><em>translation</em></a> and <a class="reference internal" href="scaling.html"><em>scaling</em></a>. <a class="reference internal" href="#affine-image-shear"><em>Shear</em></a> is described below.</p>
</div>
</div>
<div class="section" id="some-related-transforms">
<h2><a class="toc-backref" href="#id4">Some related transforms</a><a class="headerlink" href="#some-related-transforms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="conformal-affine-transform">
<span id="affine-conformal-affine-transform"></span><h3><a class="toc-backref" href="#id5">Conformal affine transform</a><a class="headerlink" href="#conformal-affine-transform" title="Permalink to this headline">¶</a></h3>
<p>A <em>conformal affine transform</em> is special case of an affine transform
where all angles remain the same. It is specified by two corresponding
pairs of points, or four parameters, which satisfy equation
<a href="#equation-matrix-form">(2)</a> with T given by:</p>
<div class="math" id="equation-conformal-affine-transform">
<span class="eqno">(5)</span>\[\begin{split}T =
  \begin{bmatrix}
     a &amp; -b \\
     b &amp;  a \\
     c &amp;  d
  \end{bmatrix}\end{split}\]</div>
<p>The four parameters correspond to homogeneous scaling, rotation, and x
and y translation.</p>
</div>
<div class="section" id="projective-transform">
<span id="affine-projective-transform"></span><h3><a class="toc-backref" href="#id6">Projective transform</a><a class="headerlink" href="#projective-transform" title="Permalink to this headline">¶</a></h3>
<p>When you look at an object in a plane from some arbitrary direction at
a <em>finite distance</em>, you get an additional &#8220;keystone&#8221; distortion in
the image. This is a <em>projective transform</em>, which keeps straight
lines straight but does not preserve the angles between lines. This
warping cannot be described by a linear affine transformation, and in
fact differs by x- and y-dependent terms in the denominator:</p>
<div class="math" id="equation-projective-transform">
<span class="eqno">(6)</span>\[\begin{split}x' &amp;= \frac{(ax + by + c)}{(gx + hy + 1)} \\
{} \\
y' &amp;= \frac{(dx + ey + f)}{(gx + hy + 1)}\end{split}\]</div>
<p>It takes 4 points, or eight coefficients, to describe this
transformation. The projective transform can equivalently be described
by the (transposed) matrix equations:</p>
<div class="math" id="equation-projective-transform-matrix">
<span class="eqno">(7)</span>\[\begin{split}x' &amp;= u / w \\
y' &amp;= v / w\end{split}\]</div>
<p>where:</p>
<div class="math" id="equation-uvw">
<span class="eqno">(8)</span>\[\begin{split}\begin{bmatrix}
  u &amp; v &amp; w
\end{bmatrix}
=
\begin{bmatrix}
 x &amp; y &amp; 1
\end{bmatrix} \, T\end{split}\]</div>
<p>and T is the 3x3 matrix:</p>
<div class="math" id="equation-T3x3">
<span class="eqno">(9)</span>\[\begin{split}T =
\begin{bmatrix}
  a &amp; d &amp; g \\
  b &amp; e &amp; h \\
  c &amp; f &amp; 1
\end{bmatrix}\end{split}\]</div>
<p>Compared with the affine transform, the extra point (or 2 parameters)
allows specification of a keystone warp by the relative distances
between pairs of points. Because the projective transform is not
linear, it cannot be composed as a sequence of translations, shears,
scalings and (optionally) rotations.</p>
<p>The eight coefficients in <a href="#equation-projective-transform">(6)</a> can be computed
from four corresponding pairs of points (8 equations). No three points
may be collinear.  Projective transforms, and their effects on images,
are implemented in <span class="filesystem">projective.c</span>. As with the affine transform,
both sampling and interpolation implementations are given of the
transform, with the interpolation method being about 5x slower.</p>
<p>It is possible to speed up the interpolation by a small amount by
dividing the pixels into 4 x 4 subpixels (instead of 16 x 16 subpixels),
and inlining an approximation for each of the 16 cases.  (See the
low-level implementation of <tt class="docutils literal"><span class="pre">pixRotateAMColorFast()</span></tt> for the method.)
This can be also be done for affine and bilinear transforms.  The speed
increase is less than 20%, so in most cases it is not worth the increase
in complexity.</p>
</div>
<div class="section" id="bilinear-transform">
<span id="affine-bilinear-transform"></span><h3><a class="toc-backref" href="#id7">Bilinear transform</a><a class="headerlink" href="#bilinear-transform" title="Permalink to this headline">¶</a></h3>
<p>The <em>bilinear transform</em> is another nonlinear 4-point transform, which
is somewhat better-conditioned than the projective transform, and a
little faster to compute because it doesn&#8217;t require a division.
Although the bilinear transform does not preserve straight lines, it can
be used to approximate a projective transform in situations where the
warp is small.</p>
<p>The bilinear transform has a nonlinear cross-term in the
transformation equation:</p>
<div class="math" id="equation-bilinear-transform">
<span class="eqno">(10)</span>\[\begin{split}x' &amp;= ax + by + cxy + d \\
y' &amp;= ex + fy + gxy + h\end{split}\]</div>
<p>and can equivalently be described by the matrix equation:</p>
<div class="math" id="equation-bilinear-transform-matrix">
<span class="eqno">(11)</span>\[\begin{split}\begin{bmatrix}
  x' &amp; y'
\end{bmatrix}
=
\begin{bmatrix}
 x &amp; y &amp; xy &amp; 1
\end{bmatrix} \, T\end{split}\]</div>
<p>where T is the 4x2 matrix:</p>
<div class="math" id="equation-T4x2">
<span class="eqno">(12)</span>\[\begin{split}T =
\begin{bmatrix}
  a &amp; e \\
  b &amp; f \\
  c &amp; g \\
  d &amp; h
\end{bmatrix}\end{split}\]</div>
<p>Like the projective transform, the bilinear transform cannot be
composed as a sequence of translation, scaling and shears. Bilinear
tranforms of images are implemented in <span class="filesystem">bilinear.c</span>, for both
sampling and interpolation of the src image.</p>
</div>
</div>
<div class="section" id="shearing-an-image">
<span id="affine-image-shear"></span><h2><a class="toc-backref" href="#id8">Shearing an image</a><a class="headerlink" href="#shearing-an-image" title="Permalink to this headline">¶</a></h2>
<p>It is useful to have horizontal shears about an arbitrary horizontal
line, and vertical shears about an arbitrary vertical line. For
horizontal shears, pixels are moved horizontally by a distance that
increases linearly with the (vertical) distance from the horizontal
line, moving to the right above the line and to the left below the
line for positive angles. Likewise, for vertical shear, pixels are
moved vertically by a distance the increases linearly with the
(horizontal) distance from the vertical line, moving downward to the
right of the line and upward to the left of the line for positive
angles.</p>
<p>Formally, a horizontal shear of angle <span class="math">\(\theta\)</span> about a line <span class="math">\(y = b\)</span>, with
the origin at the UL corner and a cw rotation taken to be positive, is:</p>
<div class="math" id="equation-shear">
<span class="eqno">(13)</span>\[\begin{split}\begin{bmatrix}
  x' &amp; y'
\end{bmatrix}
=
\begin{bmatrix}
 x &amp; y &amp; 1
\end{bmatrix} \, T\end{split}\]</div>
<p>where T is the 3x2 matrix:</p>
<div class="math" id="equation-T-h-shear">
<span class="eqno">(14)</span>\[\begin{split}T =
\begin{bmatrix}
       1          &amp; 0 \\
  -\tan (\theta)  &amp; 1 \\
  b \tan (\theta) &amp; 0
\end{bmatrix}\end{split}\]</div>
<p>Likewise, a vertical shear of angle <span class="math">\(\theta\)</span> about a line <span class="math">\(x = a\)</span> is
given by <a href="#equation-shear">(13)</a> with:</p>
<div class="math" id="equation-T-v-shear">
<span class="eqno">(15)</span>\[\begin{split}T =
\begin{bmatrix}
  1 &amp; -\tan (\theta) \\
  0 &amp; 1 \\
  0 &amp;  a \tan (\theta)
\end{bmatrix}\end{split}\]</div>
<p>All interfaces to implementations of shear in <strong>Leptonica</strong> are given at
a high level, using the <tt class="docutils literal"><span class="pre">PIX</span></tt> data structure. Two-image shear, where
the src is unchanged, is implemented by <tt class="docutils literal"><span class="pre">pixRasterop()</span></tt>.  For example,
a horizontal shear requires moving full-width blocks of pixels
horizontally by varying amounts, depending on the vertical location of
the block. The height of the block is inversely proportional to the
shear angle, appropriately integerized. We express angles in radians,
which are a natural unit, because for small angles the height of each
block is approximately equal to the inverse of the shear angle.</p>
<p>We provide special cases where the image is sheared about the upper-left
corner and also about the center. When shearing by very small angles,
the block height (for horizontal shear) is large. When shearing about
the upper-left corner, the height of the block that is not moved is only
half the block height, whereas when shearing about the center of the
image, the &#8220;dead zone&#8221; is the full block height.</p>
<p>We also provide in-place versions of shear, implemented by block
shearing of the in-place rasterop functions <tt class="docutils literal"><span class="pre">pixRasteropHip()</span></tt> and
<tt class="docutils literal"><span class="pre">pixRasteropVip()</span></tt>. The higher level two-image horizontal and vertical
shear functions <tt class="docutils literal"><span class="pre">pixHShear()</span></tt> and <tt class="docutils literal"><span class="pre">pixVShear()</span></tt> call the in-place
shear functions <tt class="docutils literal"><span class="pre">pixHShearIP()</span></tt> and <tt class="docutils literal"><span class="pre">pixVShearIP()</span></tt> when the src and
dest images are the same.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div style="text-align: center; padding-right: 5px;">
 <a href="http://www.leptonica.com" >
  <img src="../_static/moller52-smaller.jpg" border="0" alt="Leptonica Home"/>
 </a>
</div>



<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">The Leptonica Image Processing Library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="README.html">README</a></li>
<li class="toctree-l2"><a class="reference internal" href="local-sources.html">Source Code and Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="source-downloads.html">Source Downloads</a></li>
<li class="toctree-l2"><a class="reference internal" href="library-overview.html">Overview of the Leptonica Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="library-notes.html">Supplemental Notes on Using the Library</a></li>
<li class="toctree-l2"><a class="reference internal" href="src-dir.html"><span class="filesystem">/src</span> Directory Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="prog-dir.html"><span class="filesystem">/prog</span> Directory Contents</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="operations.html">Image Processing Operations</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="rasterops.html">Rasterop (a.k.a. Bitblt)</a></li>
<li class="toctree-l3"><a class="reference internal" href="binary-morphology.html">Binary Morphology</a></li>
<li class="toctree-l3"><a class="reference internal" href="grayscale-morphology.html">Grayscale Morphology</a></li>
<li class="toctree-l3"><a class="reference internal" href="convolution.html">Fast Convolution</a></li>
<li class="toctree-l3"><a class="reference internal" href="scaling.html">Image Scaling</a></li>
<li class="toctree-l3"><a class="reference internal" href="rotation.html">Image Rotation</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Affine Transformations (and cousins)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#what-is-an-affine-transformation">What is an affine transformation?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-are-affine-transformations-implemented">How are affine transformations implemented?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#some-related-transforms">Some related transforms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#shearing-an-image">Shearing an image</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="filling.html">Seed Filling and Connected Components</a></li>
<li class="toctree-l3"><a class="reference internal" href="enhancement.html">Grayscale and Color Image Enhancement</a></li>
<li class="toctree-l3"><a class="reference internal" href="binarization.html">Grayscale Mapping and Binarization</a></li>
<li class="toctree-l3"><a class="reference internal" href="thinning.html">Connectivity-preserving Thinning</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="applications.html">Image Processing Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="byte-addressing.html">Byte Addressing for Efficiency and Portability</a></li>
<li class="toctree-l2"><a class="reference internal" href="testing-methods.html">What is &#8220;Well-Tested&#8221; C Code?</a></li>
<li class="toctree-l2"><a class="reference internal" href="design-principles.html">Some Issues in Software Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="recent-pubs.html">Selected Papers on Image Processing and Image Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="about-the-license.html">About the Copyright License</a></li>
<li class="toctree-l2"><a class="reference internal" href="about-the-name.html">What is the Significance of the Name &#8220;leptonica&#8221;?</a></li>
<li class="toctree-l2"><a class="reference internal" href="version-notes.html">Version Notes for Leptonica</a></li>
<li class="toctree-l2"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vs2008/index.html">Leptonica &amp; Visual Studio 2008</a></li>
<li class="toctree-l1"><a class="reference internal" href="../other/index.html">Other Topics</a></li>
</ul>


  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/leptonica/affine.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="filling.html" title="Seed Filling and Connected Components"
             >next</a></li>
        <li class="right" >
          <a href="rotation.html" title="Image Rotation"
             >previous</a> |</li>
  <li><a href="http://www.leptonica.com">Leptonica Home</a> &raquo;</li>
  
        <li><a href="../index.html">Unofficial v1.67 Documentation</a> &raquo;</li>

          <li><a href="index.html" >The Leptonica Image Processing Library</a> &raquo;</li>
          <li><a href="operations.html" >Image Processing Operations</a> &raquo;</li> 
      </ul>
    </div>
  <div class="footer">

   <p class="creativecommons">
    <a href="http://creativecommons.org/licenses/by/3.0/us/" >
      <img src="../_static/creativecommons-88x31.png"
	   border="0" alt="Creative Commons License"/>
     </a>
    Leptonica by 
    <a href="http://leptonica.com/www.leptonica.org">
    Dan Bloomberg
    </a>
    is licensed under a
    <a href="http://creativecommons.org/licenses/by/3.0/us/">
     Creative Commons Attribution 3.0 United States License.
    </a>
   </p>


   <p class="sphinxcredit">Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
   </p>
    <script type="text/javascript">
      _uacct = "UA-144810-1";
      urchinTracker();
    </script>
  </div>
  </body>
</html>